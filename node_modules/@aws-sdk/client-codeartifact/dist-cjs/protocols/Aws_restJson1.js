"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deserializeAws_restJson1DisassociateExternalConnectionCommand = exports.deserializeAws_restJson1DescribeRepositoryCommand = exports.deserializeAws_restJson1DescribePackageVersionCommand = exports.deserializeAws_restJson1DescribePackageCommand = exports.deserializeAws_restJson1DescribeDomainCommand = exports.deserializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand = exports.deserializeAws_restJson1DeleteRepositoryCommand = exports.deserializeAws_restJson1DeletePackageVersionsCommand = exports.deserializeAws_restJson1DeleteDomainPermissionsPolicyCommand = exports.deserializeAws_restJson1DeleteDomainCommand = exports.deserializeAws_restJson1CreateRepositoryCommand = exports.deserializeAws_restJson1CreateDomainCommand = exports.deserializeAws_restJson1CopyPackageVersionsCommand = exports.deserializeAws_restJson1AssociateExternalConnectionCommand = exports.serializeAws_restJson1UpdateRepositoryCommand = exports.serializeAws_restJson1UpdatePackageVersionsStatusCommand = exports.serializeAws_restJson1UntagResourceCommand = exports.serializeAws_restJson1TagResourceCommand = exports.serializeAws_restJson1PutRepositoryPermissionsPolicyCommand = exports.serializeAws_restJson1PutPackageOriginConfigurationCommand = exports.serializeAws_restJson1PutDomainPermissionsPolicyCommand = exports.serializeAws_restJson1ListTagsForResourceCommand = exports.serializeAws_restJson1ListRepositoriesInDomainCommand = exports.serializeAws_restJson1ListRepositoriesCommand = exports.serializeAws_restJson1ListPackageVersionsCommand = exports.serializeAws_restJson1ListPackageVersionDependenciesCommand = exports.serializeAws_restJson1ListPackageVersionAssetsCommand = exports.serializeAws_restJson1ListPackagesCommand = exports.serializeAws_restJson1ListDomainsCommand = exports.serializeAws_restJson1GetRepositoryPermissionsPolicyCommand = exports.serializeAws_restJson1GetRepositoryEndpointCommand = exports.serializeAws_restJson1GetPackageVersionReadmeCommand = exports.serializeAws_restJson1GetPackageVersionAssetCommand = exports.serializeAws_restJson1GetDomainPermissionsPolicyCommand = exports.serializeAws_restJson1GetAuthorizationTokenCommand = exports.serializeAws_restJson1DisposePackageVersionsCommand = exports.serializeAws_restJson1DisassociateExternalConnectionCommand = exports.serializeAws_restJson1DescribeRepositoryCommand = exports.serializeAws_restJson1DescribePackageVersionCommand = exports.serializeAws_restJson1DescribePackageCommand = exports.serializeAws_restJson1DescribeDomainCommand = exports.serializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand = exports.serializeAws_restJson1DeleteRepositoryCommand = exports.serializeAws_restJson1DeletePackageVersionsCommand = exports.serializeAws_restJson1DeleteDomainPermissionsPolicyCommand = exports.serializeAws_restJson1DeleteDomainCommand = exports.serializeAws_restJson1CreateRepositoryCommand = exports.serializeAws_restJson1CreateDomainCommand = exports.serializeAws_restJson1CopyPackageVersionsCommand = exports.serializeAws_restJson1AssociateExternalConnectionCommand = void 0;
exports.deserializeAws_restJson1UpdateRepositoryCommand = exports.deserializeAws_restJson1UpdatePackageVersionsStatusCommand = exports.deserializeAws_restJson1UntagResourceCommand = exports.deserializeAws_restJson1TagResourceCommand = exports.deserializeAws_restJson1PutRepositoryPermissionsPolicyCommand = exports.deserializeAws_restJson1PutPackageOriginConfigurationCommand = exports.deserializeAws_restJson1PutDomainPermissionsPolicyCommand = exports.deserializeAws_restJson1ListTagsForResourceCommand = exports.deserializeAws_restJson1ListRepositoriesInDomainCommand = exports.deserializeAws_restJson1ListRepositoriesCommand = exports.deserializeAws_restJson1ListPackageVersionsCommand = exports.deserializeAws_restJson1ListPackageVersionDependenciesCommand = exports.deserializeAws_restJson1ListPackageVersionAssetsCommand = exports.deserializeAws_restJson1ListPackagesCommand = exports.deserializeAws_restJson1ListDomainsCommand = exports.deserializeAws_restJson1GetRepositoryPermissionsPolicyCommand = exports.deserializeAws_restJson1GetRepositoryEndpointCommand = exports.deserializeAws_restJson1GetPackageVersionReadmeCommand = exports.deserializeAws_restJson1GetPackageVersionAssetCommand = exports.deserializeAws_restJson1GetDomainPermissionsPolicyCommand = exports.deserializeAws_restJson1GetAuthorizationTokenCommand = exports.deserializeAws_restJson1DisposePackageVersionsCommand = void 0;
const protocol_http_1 = require("@aws-sdk/protocol-http");
const smithy_client_1 = require("@aws-sdk/smithy-client");
const CodeartifactServiceException_1 = require("../models/CodeartifactServiceException");
const models_0_1 = require("../models/models_0");
const serializeAws_restJson1AssociateExternalConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository/external-connection";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.externalConnection !== undefined && { "external-connection": input.externalConnection }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1AssociateExternalConnectionCommand = serializeAws_restJson1AssociateExternalConnectionCommand;
const serializeAws_restJson1CopyPackageVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/versions/copy";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.sourceRepository !== undefined && { "source-repository": input.sourceRepository }),
        ...(input.destinationRepository !== undefined && { "destination-repository": input.destinationRepository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
    };
    let body;
    body = JSON.stringify({
        ...(input.allowOverwrite != null && { allowOverwrite: input.allowOverwrite }),
        ...(input.includeFromUpstream != null && { includeFromUpstream: input.includeFromUpstream }),
        ...(input.versionRevisions != null && {
            versionRevisions: serializeAws_restJson1PackageVersionRevisionMap(input.versionRevisions, context),
        }),
        ...(input.versions != null && { versions: serializeAws_restJson1PackageVersionList(input.versions, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CopyPackageVersionsCommand = serializeAws_restJson1CopyPackageVersionsCommand;
const serializeAws_restJson1CreateDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
    };
    let body;
    body = JSON.stringify({
        ...(input.encryptionKey != null && { encryptionKey: input.encryptionKey }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CreateDomainCommand = serializeAws_restJson1CreateDomainCommand;
const serializeAws_restJson1CreateRepositoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
    };
    let body;
    body = JSON.stringify({
        ...(input.description != null && { description: input.description }),
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
        ...(input.upstreams != null && {
            upstreams: serializeAws_restJson1UpstreamRepositoryList(input.upstreams, context),
        }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1CreateRepositoryCommand = serializeAws_restJson1CreateRepositoryCommand;
const serializeAws_restJson1DeleteDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteDomainCommand = serializeAws_restJson1DeleteDomainCommand;
const serializeAws_restJson1DeleteDomainPermissionsPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain/permissions/policy";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.policyRevision !== undefined && { "policy-revision": input.policyRevision }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteDomainPermissionsPolicyCommand = serializeAws_restJson1DeleteDomainPermissionsPolicyCommand;
const serializeAws_restJson1DeletePackageVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/versions/delete";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
    };
    let body;
    body = JSON.stringify({
        ...(input.expectedStatus != null && { expectedStatus: input.expectedStatus }),
        ...(input.versions != null && { versions: serializeAws_restJson1PackageVersionList(input.versions, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeletePackageVersionsCommand = serializeAws_restJson1DeletePackageVersionsCommand;
const serializeAws_restJson1DeleteRepositoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteRepositoryCommand = serializeAws_restJson1DeleteRepositoryCommand;
const serializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository/permissions/policies";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.policyRevision !== undefined && { "policy-revision": input.policyRevision }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand = serializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand;
const serializeAws_restJson1DescribeDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribeDomainCommand = serializeAws_restJson1DescribeDomainCommand;
const serializeAws_restJson1DescribePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribePackageCommand = serializeAws_restJson1DescribePackageCommand;
const serializeAws_restJson1DescribePackageVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/version";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
        ...(input.packageVersion !== undefined && { version: input.packageVersion }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribePackageVersionCommand = serializeAws_restJson1DescribePackageVersionCommand;
const serializeAws_restJson1DescribeRepositoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DescribeRepositoryCommand = serializeAws_restJson1DescribeRepositoryCommand;
const serializeAws_restJson1DisassociateExternalConnectionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository/external-connection";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.externalConnection !== undefined && { "external-connection": input.externalConnection }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DisassociateExternalConnectionCommand = serializeAws_restJson1DisassociateExternalConnectionCommand;
const serializeAws_restJson1DisposePackageVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/versions/dispose";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
    };
    let body;
    body = JSON.stringify({
        ...(input.expectedStatus != null && { expectedStatus: input.expectedStatus }),
        ...(input.versionRevisions != null && {
            versionRevisions: serializeAws_restJson1PackageVersionRevisionMap(input.versionRevisions, context),
        }),
        ...(input.versions != null && { versions: serializeAws_restJson1PackageVersionList(input.versions, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1DisposePackageVersionsCommand = serializeAws_restJson1DisposePackageVersionsCommand;
const serializeAws_restJson1GetAuthorizationTokenCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/authorization-token";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.durationSeconds !== undefined && { duration: input.durationSeconds.toString() }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetAuthorizationTokenCommand = serializeAws_restJson1GetAuthorizationTokenCommand;
const serializeAws_restJson1GetDomainPermissionsPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain/permissions/policy";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetDomainPermissionsPolicyCommand = serializeAws_restJson1GetDomainPermissionsPolicyCommand;
const serializeAws_restJson1GetPackageVersionAssetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/version/asset";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
        ...(input.packageVersion !== undefined && { version: input.packageVersion }),
        ...(input.asset !== undefined && { asset: input.asset }),
        ...(input.packageVersionRevision !== undefined && { revision: input.packageVersionRevision }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetPackageVersionAssetCommand = serializeAws_restJson1GetPackageVersionAssetCommand;
const serializeAws_restJson1GetPackageVersionReadmeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/version/readme";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
        ...(input.packageVersion !== undefined && { version: input.packageVersion }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetPackageVersionReadmeCommand = serializeAws_restJson1GetPackageVersionReadmeCommand;
const serializeAws_restJson1GetRepositoryEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository/endpoint";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetRepositoryEndpointCommand = serializeAws_restJson1GetRepositoryEndpointCommand;
const serializeAws_restJson1GetRepositoryPermissionsPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository/permissions/policy";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1GetRepositoryPermissionsPolicyCommand = serializeAws_restJson1GetRepositoryPermissionsPolicyCommand;
const serializeAws_restJson1ListDomainsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domains";
    let body;
    body = JSON.stringify({
        ...(input.maxResults != null && { maxResults: input.maxResults }),
        ...(input.nextToken != null && { nextToken: input.nextToken }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1ListDomainsCommand = serializeAws_restJson1ListDomainsCommand;
const serializeAws_restJson1ListPackagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/packages";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.packagePrefix !== undefined && { "package-prefix": input.packagePrefix }),
        ...(input.maxResults !== undefined && { "max-results": input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { "next-token": input.nextToken }),
        ...(input.publish !== undefined && { publish: input.publish }),
        ...(input.upstream !== undefined && { upstream: input.upstream }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPackagesCommand = serializeAws_restJson1ListPackagesCommand;
const serializeAws_restJson1ListPackageVersionAssetsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/version/assets";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
        ...(input.packageVersion !== undefined && { version: input.packageVersion }),
        ...(input.maxResults !== undefined && { "max-results": input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { "next-token": input.nextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPackageVersionAssetsCommand = serializeAws_restJson1ListPackageVersionAssetsCommand;
const serializeAws_restJson1ListPackageVersionDependenciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/version/dependencies";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
        ...(input.packageVersion !== undefined && { version: input.packageVersion }),
        ...(input.nextToken !== undefined && { "next-token": input.nextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPackageVersionDependenciesCommand = serializeAws_restJson1ListPackageVersionDependenciesCommand;
const serializeAws_restJson1ListPackageVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/versions";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
        ...(input.status !== undefined && { status: input.status }),
        ...(input.sortBy !== undefined && { sortBy: input.sortBy }),
        ...(input.maxResults !== undefined && { "max-results": input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { "next-token": input.nextToken }),
        ...(input.originType !== undefined && { originType: input.originType }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListPackageVersionsCommand = serializeAws_restJson1ListPackageVersionsCommand;
const serializeAws_restJson1ListRepositoriesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repositories";
    const query = {
        ...(input.repositoryPrefix !== undefined && { "repository-prefix": input.repositoryPrefix }),
        ...(input.maxResults !== undefined && { "max-results": input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { "next-token": input.nextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListRepositoriesCommand = serializeAws_restJson1ListRepositoriesCommand;
const serializeAws_restJson1ListRepositoriesInDomainCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain/repositories";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.administratorAccount !== undefined && { "administrator-account": input.administratorAccount }),
        ...(input.repositoryPrefix !== undefined && { "repository-prefix": input.repositoryPrefix }),
        ...(input.maxResults !== undefined && { "max-results": input.maxResults.toString() }),
        ...(input.nextToken !== undefined && { "next-token": input.nextToken }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListRepositoriesInDomainCommand = serializeAws_restJson1ListRepositoriesInDomainCommand;
const serializeAws_restJson1ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tags";
    const query = {
        ...(input.resourceArn !== undefined && { resourceArn: input.resourceArn }),
    };
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1ListTagsForResourceCommand = serializeAws_restJson1ListTagsForResourceCommand;
const serializeAws_restJson1PutDomainPermissionsPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/domain/permissions/policy";
    let body;
    body = JSON.stringify({
        ...(input.domain != null && { domain: input.domain }),
        ...(input.domainOwner != null && { domainOwner: input.domainOwner }),
        ...(input.policyDocument != null && { policyDocument: input.policyDocument }),
        ...(input.policyRevision != null && { policyRevision: input.policyRevision }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.serializeAws_restJson1PutDomainPermissionsPolicyCommand = serializeAws_restJson1PutDomainPermissionsPolicyCommand;
const serializeAws_restJson1PutPackageOriginConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
    };
    let body;
    body = JSON.stringify({
        ...(input.restrictions != null && {
            restrictions: serializeAws_restJson1PackageOriginRestrictions(input.restrictions, context),
        }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1PutPackageOriginConfigurationCommand = serializeAws_restJson1PutPackageOriginConfigurationCommand;
const serializeAws_restJson1PutRepositoryPermissionsPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository/permissions/policy";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
    };
    let body;
    body = JSON.stringify({
        ...(input.policyDocument != null && { policyDocument: input.policyDocument }),
        ...(input.policyRevision != null && { policyRevision: input.policyRevision }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1PutRepositoryPermissionsPolicyCommand = serializeAws_restJson1PutRepositoryPermissionsPolicyCommand;
const serializeAws_restJson1TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/tag";
    const query = {
        ...(input.resourceArn !== undefined && { resourceArn: input.resourceArn }),
    };
    let body;
    body = JSON.stringify({
        ...(input.tags != null && { tags: serializeAws_restJson1TagList(input.tags, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1TagResourceCommand = serializeAws_restJson1TagResourceCommand;
const serializeAws_restJson1UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/untag";
    const query = {
        ...(input.resourceArn !== undefined && { resourceArn: input.resourceArn }),
    };
    let body;
    body = JSON.stringify({
        ...(input.tagKeys != null && { tagKeys: serializeAws_restJson1TagKeyList(input.tagKeys, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UntagResourceCommand = serializeAws_restJson1UntagResourceCommand;
const serializeAws_restJson1UpdatePackageVersionsStatusCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/package/versions/update_status";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
        ...(input.format !== undefined && { format: input.format }),
        ...(input.namespace !== undefined && { namespace: input.namespace }),
        ...(input.package !== undefined && { package: input.package }),
    };
    let body;
    body = JSON.stringify({
        ...(input.expectedStatus != null && { expectedStatus: input.expectedStatus }),
        ...(input.targetStatus != null && { targetStatus: input.targetStatus }),
        ...(input.versionRevisions != null && {
            versionRevisions: serializeAws_restJson1PackageVersionRevisionMap(input.versionRevisions, context),
        }),
        ...(input.versions != null && { versions: serializeAws_restJson1PackageVersionList(input.versions, context) }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UpdatePackageVersionsStatusCommand = serializeAws_restJson1UpdatePackageVersionsStatusCommand;
const serializeAws_restJson1UpdateRepositoryCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}` + "/v1/repository";
    const query = {
        ...(input.domain !== undefined && { domain: input.domain }),
        ...(input.domainOwner !== undefined && { "domain-owner": input.domainOwner }),
        ...(input.repository !== undefined && { repository: input.repository }),
    };
    let body;
    body = JSON.stringify({
        ...(input.description != null && { description: input.description }),
        ...(input.upstreams != null && {
            upstreams: serializeAws_restJson1UpstreamRepositoryList(input.upstreams, context),
        }),
    });
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.serializeAws_restJson1UpdateRepositoryCommand = serializeAws_restJson1UpdateRepositoryCommand;
const deserializeAws_restJson1AssociateExternalConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1AssociateExternalConnectionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repository: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repository !== undefined && data.repository !== null) {
        contents.repository = deserializeAws_restJson1RepositoryDescription(data.repository, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1AssociateExternalConnectionCommand = deserializeAws_restJson1AssociateExternalConnectionCommand;
const deserializeAws_restJson1AssociateExternalConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CopyPackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CopyPackageVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        failedVersions: undefined,
        successfulVersions: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.failedVersions !== undefined && data.failedVersions !== null) {
        contents.failedVersions = deserializeAws_restJson1PackageVersionErrorMap(data.failedVersions, context);
    }
    if (data.successfulVersions !== undefined && data.successfulVersions !== null) {
        contents.successfulVersions = deserializeAws_restJson1SuccessfulPackageVersionInfoMap(data.successfulVersions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CopyPackageVersionsCommand = deserializeAws_restJson1CopyPackageVersionsCommand;
const deserializeAws_restJson1CopyPackageVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateDomainCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domain: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.domain !== undefined && data.domain !== null) {
        contents.domain = deserializeAws_restJson1DomainDescription(data.domain, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateDomainCommand = deserializeAws_restJson1CreateDomainCommand;
const deserializeAws_restJson1CreateDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1CreateRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1CreateRepositoryCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repository: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repository !== undefined && data.repository !== null) {
        contents.repository = deserializeAws_restJson1RepositoryDescription(data.repository, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1CreateRepositoryCommand = deserializeAws_restJson1CreateRepositoryCommand;
const deserializeAws_restJson1CreateRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDomainCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domain: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.domain !== undefined && data.domain !== null) {
        contents.domain = deserializeAws_restJson1DomainDescription(data.domain, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteDomainCommand = deserializeAws_restJson1DeleteDomainCommand;
const deserializeAws_restJson1DeleteDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteDomainPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteDomainPermissionsPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policy: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.policy !== undefined && data.policy !== null) {
        contents.policy = deserializeAws_restJson1ResourcePolicy(data.policy, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteDomainPermissionsPolicyCommand = deserializeAws_restJson1DeleteDomainPermissionsPolicyCommand;
const deserializeAws_restJson1DeleteDomainPermissionsPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeletePackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeletePackageVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        failedVersions: undefined,
        successfulVersions: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.failedVersions !== undefined && data.failedVersions !== null) {
        contents.failedVersions = deserializeAws_restJson1PackageVersionErrorMap(data.failedVersions, context);
    }
    if (data.successfulVersions !== undefined && data.successfulVersions !== null) {
        contents.successfulVersions = deserializeAws_restJson1SuccessfulPackageVersionInfoMap(data.successfulVersions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeletePackageVersionsCommand = deserializeAws_restJson1DeletePackageVersionsCommand;
const deserializeAws_restJson1DeletePackageVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteRepositoryCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repository: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repository !== undefined && data.repository !== null) {
        contents.repository = deserializeAws_restJson1RepositoryDescription(data.repository, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteRepositoryCommand = deserializeAws_restJson1DeleteRepositoryCommand;
const deserializeAws_restJson1DeleteRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DeleteRepositoryPermissionsPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policy: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.policy !== undefined && data.policy !== null) {
        contents.policy = deserializeAws_restJson1ResourcePolicy(data.policy, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand = deserializeAws_restJson1DeleteRepositoryPermissionsPolicyCommand;
const deserializeAws_restJson1DeleteRepositoryPermissionsPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeDomainCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domain: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.domain !== undefined && data.domain !== null) {
        contents.domain = deserializeAws_restJson1DomainDescription(data.domain, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeDomainCommand = deserializeAws_restJson1DescribeDomainCommand;
const deserializeAws_restJson1DescribeDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribePackageCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        package: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.package !== undefined && data.package !== null) {
        contents.package = deserializeAws_restJson1PackageDescription(data.package, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribePackageCommand = deserializeAws_restJson1DescribePackageCommand;
const deserializeAws_restJson1DescribePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribePackageVersionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        packageVersion: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.packageVersion !== undefined && data.packageVersion !== null) {
        contents.packageVersion = deserializeAws_restJson1PackageVersionDescription(data.packageVersion, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribePackageVersionCommand = deserializeAws_restJson1DescribePackageVersionCommand;
const deserializeAws_restJson1DescribePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DescribeRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DescribeRepositoryCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repository: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repository !== undefined && data.repository !== null) {
        contents.repository = deserializeAws_restJson1RepositoryDescription(data.repository, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DescribeRepositoryCommand = deserializeAws_restJson1DescribeRepositoryCommand;
const deserializeAws_restJson1DescribeRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DisassociateExternalConnectionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DisassociateExternalConnectionCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repository: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repository !== undefined && data.repository !== null) {
        contents.repository = deserializeAws_restJson1RepositoryDescription(data.repository, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisassociateExternalConnectionCommand = deserializeAws_restJson1DisassociateExternalConnectionCommand;
const deserializeAws_restJson1DisassociateExternalConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1DisposePackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1DisposePackageVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        failedVersions: undefined,
        successfulVersions: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.failedVersions !== undefined && data.failedVersions !== null) {
        contents.failedVersions = deserializeAws_restJson1PackageVersionErrorMap(data.failedVersions, context);
    }
    if (data.successfulVersions !== undefined && data.successfulVersions !== null) {
        contents.successfulVersions = deserializeAws_restJson1SuccessfulPackageVersionInfoMap(data.successfulVersions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1DisposePackageVersionsCommand = deserializeAws_restJson1DisposePackageVersionsCommand;
const deserializeAws_restJson1DisposePackageVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetAuthorizationTokenCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetAuthorizationTokenCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        authorizationToken: undefined,
        expiration: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.authorizationToken !== undefined && data.authorizationToken !== null) {
        contents.authorizationToken = (0, smithy_client_1.expectString)(data.authorizationToken);
    }
    if (data.expiration !== undefined && data.expiration !== null) {
        contents.expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(data.expiration)));
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetAuthorizationTokenCommand = deserializeAws_restJson1GetAuthorizationTokenCommand;
const deserializeAws_restJson1GetAuthorizationTokenCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetDomainPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetDomainPermissionsPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policy: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.policy !== undefined && data.policy !== null) {
        contents.policy = deserializeAws_restJson1ResourcePolicy(data.policy, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetDomainPermissionsPolicyCommand = deserializeAws_restJson1GetDomainPermissionsPolicyCommand;
const deserializeAws_restJson1GetDomainPermissionsPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetPackageVersionAssetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPackageVersionAssetCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        asset: undefined,
        assetName: undefined,
        packageVersion: undefined,
        packageVersionRevision: undefined,
    };
    if (output.headers["x-assetname"] !== undefined) {
        contents.assetName = output.headers["x-assetname"];
    }
    if (output.headers["x-packageversion"] !== undefined) {
        contents.packageVersion = output.headers["x-packageversion"];
    }
    if (output.headers["x-packageversionrevision"] !== undefined) {
        contents.packageVersionRevision = output.headers["x-packageversionrevision"];
    }
    const data = output.body;
    contents.asset = data;
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPackageVersionAssetCommand = deserializeAws_restJson1GetPackageVersionAssetCommand;
const deserializeAws_restJson1GetPackageVersionAssetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetPackageVersionReadmeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetPackageVersionReadmeCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        format: undefined,
        namespace: undefined,
        package: undefined,
        readme: undefined,
        version: undefined,
        versionRevision: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.format !== undefined && data.format !== null) {
        contents.format = (0, smithy_client_1.expectString)(data.format);
    }
    if (data.namespace !== undefined && data.namespace !== null) {
        contents.namespace = (0, smithy_client_1.expectString)(data.namespace);
    }
    if (data.package !== undefined && data.package !== null) {
        contents.package = (0, smithy_client_1.expectString)(data.package);
    }
    if (data.readme !== undefined && data.readme !== null) {
        contents.readme = (0, smithy_client_1.expectString)(data.readme);
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = (0, smithy_client_1.expectString)(data.version);
    }
    if (data.versionRevision !== undefined && data.versionRevision !== null) {
        contents.versionRevision = (0, smithy_client_1.expectString)(data.versionRevision);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetPackageVersionReadmeCommand = deserializeAws_restJson1GetPackageVersionReadmeCommand;
const deserializeAws_restJson1GetPackageVersionReadmeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetRepositoryEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetRepositoryEndpointCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repositoryEndpoint: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repositoryEndpoint !== undefined && data.repositoryEndpoint !== null) {
        contents.repositoryEndpoint = (0, smithy_client_1.expectString)(data.repositoryEndpoint);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetRepositoryEndpointCommand = deserializeAws_restJson1GetRepositoryEndpointCommand;
const deserializeAws_restJson1GetRepositoryEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1GetRepositoryPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1GetRepositoryPermissionsPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policy: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.policy !== undefined && data.policy !== null) {
        contents.policy = deserializeAws_restJson1ResourcePolicy(data.policy, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1GetRepositoryPermissionsPolicyCommand = deserializeAws_restJson1GetRepositoryPermissionsPolicyCommand;
const deserializeAws_restJson1GetRepositoryPermissionsPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListDomainsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListDomainsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        domains: undefined,
        nextToken: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.domains !== undefined && data.domains !== null) {
        contents.domains = deserializeAws_restJson1DomainSummaryList(data.domains, context);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListDomainsCommand = deserializeAws_restJson1ListDomainsCommand;
const deserializeAws_restJson1ListDomainsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListPackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPackagesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        packages: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.packages !== undefined && data.packages !== null) {
        contents.packages = deserializeAws_restJson1PackageSummaryList(data.packages, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPackagesCommand = deserializeAws_restJson1ListPackagesCommand;
const deserializeAws_restJson1ListPackagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListPackageVersionAssetsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPackageVersionAssetsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        assets: undefined,
        format: undefined,
        namespace: undefined,
        nextToken: undefined,
        package: undefined,
        version: undefined,
        versionRevision: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.assets !== undefined && data.assets !== null) {
        contents.assets = deserializeAws_restJson1AssetSummaryList(data.assets, context);
    }
    if (data.format !== undefined && data.format !== null) {
        contents.format = (0, smithy_client_1.expectString)(data.format);
    }
    if (data.namespace !== undefined && data.namespace !== null) {
        contents.namespace = (0, smithy_client_1.expectString)(data.namespace);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.package !== undefined && data.package !== null) {
        contents.package = (0, smithy_client_1.expectString)(data.package);
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = (0, smithy_client_1.expectString)(data.version);
    }
    if (data.versionRevision !== undefined && data.versionRevision !== null) {
        contents.versionRevision = (0, smithy_client_1.expectString)(data.versionRevision);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPackageVersionAssetsCommand = deserializeAws_restJson1ListPackageVersionAssetsCommand;
const deserializeAws_restJson1ListPackageVersionAssetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListPackageVersionDependenciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPackageVersionDependenciesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        dependencies: undefined,
        format: undefined,
        namespace: undefined,
        nextToken: undefined,
        package: undefined,
        version: undefined,
        versionRevision: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.dependencies !== undefined && data.dependencies !== null) {
        contents.dependencies = deserializeAws_restJson1PackageDependencyList(data.dependencies, context);
    }
    if (data.format !== undefined && data.format !== null) {
        contents.format = (0, smithy_client_1.expectString)(data.format);
    }
    if (data.namespace !== undefined && data.namespace !== null) {
        contents.namespace = (0, smithy_client_1.expectString)(data.namespace);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.package !== undefined && data.package !== null) {
        contents.package = (0, smithy_client_1.expectString)(data.package);
    }
    if (data.version !== undefined && data.version !== null) {
        contents.version = (0, smithy_client_1.expectString)(data.version);
    }
    if (data.versionRevision !== undefined && data.versionRevision !== null) {
        contents.versionRevision = (0, smithy_client_1.expectString)(data.versionRevision);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPackageVersionDependenciesCommand = deserializeAws_restJson1ListPackageVersionDependenciesCommand;
const deserializeAws_restJson1ListPackageVersionDependenciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListPackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListPackageVersionsCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        defaultDisplayVersion: undefined,
        format: undefined,
        namespace: undefined,
        nextToken: undefined,
        package: undefined,
        versions: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.defaultDisplayVersion !== undefined && data.defaultDisplayVersion !== null) {
        contents.defaultDisplayVersion = (0, smithy_client_1.expectString)(data.defaultDisplayVersion);
    }
    if (data.format !== undefined && data.format !== null) {
        contents.format = (0, smithy_client_1.expectString)(data.format);
    }
    if (data.namespace !== undefined && data.namespace !== null) {
        contents.namespace = (0, smithy_client_1.expectString)(data.namespace);
    }
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.package !== undefined && data.package !== null) {
        contents.package = (0, smithy_client_1.expectString)(data.package);
    }
    if (data.versions !== undefined && data.versions !== null) {
        contents.versions = deserializeAws_restJson1PackageVersionSummaryList(data.versions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListPackageVersionsCommand = deserializeAws_restJson1ListPackageVersionsCommand;
const deserializeAws_restJson1ListPackageVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListRepositoriesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListRepositoriesCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        repositories: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.repositories !== undefined && data.repositories !== null) {
        contents.repositories = deserializeAws_restJson1RepositorySummaryList(data.repositories, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListRepositoriesCommand = deserializeAws_restJson1ListRepositoriesCommand;
const deserializeAws_restJson1ListRepositoriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListRepositoriesInDomainCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListRepositoriesInDomainCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        nextToken: undefined,
        repositories: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.nextToken !== undefined && data.nextToken !== null) {
        contents.nextToken = (0, smithy_client_1.expectString)(data.nextToken);
    }
    if (data.repositories !== undefined && data.repositories !== null) {
        contents.repositories = deserializeAws_restJson1RepositorySummaryList(data.repositories, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListRepositoriesInDomainCommand = deserializeAws_restJson1ListRepositoriesInDomainCommand;
const deserializeAws_restJson1ListRepositoriesInDomainCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1ListTagsForResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        tags: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.tags !== undefined && data.tags !== null) {
        contents.tags = deserializeAws_restJson1TagList(data.tags, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1ListTagsForResourceCommand = deserializeAws_restJson1ListTagsForResourceCommand;
const deserializeAws_restJson1ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1PutDomainPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1PutDomainPermissionsPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policy: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.policy !== undefined && data.policy !== null) {
        contents.policy = deserializeAws_restJson1ResourcePolicy(data.policy, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutDomainPermissionsPolicyCommand = deserializeAws_restJson1PutDomainPermissionsPolicyCommand;
const deserializeAws_restJson1PutDomainPermissionsPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1PutPackageOriginConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1PutPackageOriginConfigurationCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        originConfiguration: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.originConfiguration !== undefined && data.originConfiguration !== null) {
        contents.originConfiguration = deserializeAws_restJson1PackageOriginConfiguration(data.originConfiguration, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutPackageOriginConfigurationCommand = deserializeAws_restJson1PutPackageOriginConfigurationCommand;
const deserializeAws_restJson1PutPackageOriginConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1PutRepositoryPermissionsPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1PutRepositoryPermissionsPolicyCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        policy: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.policy !== undefined && data.policy !== null) {
        contents.policy = deserializeAws_restJson1ResourcePolicy(data.policy, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1PutRepositoryPermissionsPolicyCommand = deserializeAws_restJson1PutRepositoryPermissionsPolicyCommand;
const deserializeAws_restJson1PutRepositoryPermissionsPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1TagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1TagResourceCommand = deserializeAws_restJson1TagResourceCommand;
const deserializeAws_restJson1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UntagResourceCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
    };
    await collectBody(output.body, context);
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UntagResourceCommand = deserializeAws_restJson1UntagResourceCommand;
const deserializeAws_restJson1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UpdatePackageVersionsStatusCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdatePackageVersionsStatusCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        failedVersions: undefined,
        successfulVersions: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.failedVersions !== undefined && data.failedVersions !== null) {
        contents.failedVersions = deserializeAws_restJson1PackageVersionErrorMap(data.failedVersions, context);
    }
    if (data.successfulVersions !== undefined && data.successfulVersions !== null) {
        contents.successfulVersions = deserializeAws_restJson1SuccessfulPackageVersionInfoMap(data.successfulVersions, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdatePackageVersionsStatusCommand = deserializeAws_restJson1UpdatePackageVersionsStatusCommand;
const deserializeAws_restJson1UpdatePackageVersionsStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1UpdateRepositoryCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return deserializeAws_restJson1UpdateRepositoryCommandError(output, context);
    }
    const contents = {
        $metadata: deserializeMetadata(output),
        repository: undefined,
    };
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    if (data.repository !== undefined && data.repository !== null) {
        contents.repository = deserializeAws_restJson1RepositoryDescription(data.repository, context);
    }
    return Promise.resolve(contents);
};
exports.deserializeAws_restJson1UpdateRepositoryCommand = deserializeAws_restJson1UpdateRepositoryCommand;
const deserializeAws_restJson1UpdateRepositoryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseBody(output.body, context),
    };
    let response;
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.codeartifact#AccessDeniedException":
            throw await deserializeAws_restJson1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.codeartifact#ConflictException":
            throw await deserializeAws_restJson1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.codeartifact#InternalServerException":
            throw await deserializeAws_restJson1InternalServerExceptionResponse(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.codeartifact#ResourceNotFoundException":
            throw await deserializeAws_restJson1ResourceNotFoundExceptionResponse(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.codeartifact#ServiceQuotaExceededException":
            throw await deserializeAws_restJson1ServiceQuotaExceededExceptionResponse(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.codeartifact#ThrottlingException":
            throw await deserializeAws_restJson1ThrottlingExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.codeartifact#ValidationException":
            throw await deserializeAws_restJson1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            const $metadata = deserializeMetadata(output);
            const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
            response = new CodeartifactServiceException_1.CodeartifactServiceException({
                name: parsedBody.code || parsedBody.Code || errorCode || statusCode || "UnknowError",
                $fault: "client",
                $metadata,
            });
            throw (0, smithy_client_1.decorateServiceException)(response, parsedBody);
    }
};
const deserializeAws_restJson1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ConflictExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    if (data.resourceId !== undefined && data.resourceId !== null) {
        contents.resourceId = (0, smithy_client_1.expectString)(data.resourceId);
    }
    if (data.resourceType !== undefined && data.resourceType !== null) {
        contents.resourceType = (0, smithy_client_1.expectString)(data.resourceType);
    }
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1InternalServerExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ResourceNotFoundExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    if (data.resourceId !== undefined && data.resourceId !== null) {
        contents.resourceId = (0, smithy_client_1.expectString)(data.resourceId);
    }
    if (data.resourceType !== undefined && data.resourceType !== null) {
        contents.resourceType = (0, smithy_client_1.expectString)(data.resourceType);
    }
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ServiceQuotaExceededExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    if (data.resourceId !== undefined && data.resourceId !== null) {
        contents.resourceId = (0, smithy_client_1.expectString)(data.resourceId);
    }
    if (data.resourceType !== undefined && data.resourceType !== null) {
        contents.resourceType = (0, smithy_client_1.expectString)(data.resourceType);
    }
    const exception = new models_0_1.ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ThrottlingExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    if (parsedOutput.headers["retry-after"] !== undefined) {
        contents.retryAfterSeconds = (0, smithy_client_1.strictParseInt32)(parsedOutput.headers["retry-after"]);
    }
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeAws_restJson1ValidationExceptionResponse = async (parsedOutput, context) => {
    const contents = {};
    const data = parsedOutput.body;
    if (data.message !== undefined && data.message !== null) {
        contents.message = (0, smithy_client_1.expectString)(data.message);
    }
    if (data.reason !== undefined && data.reason !== null) {
        contents.reason = (0, smithy_client_1.expectString)(data.reason);
    }
    const exception = new models_0_1.ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const serializeAws_restJson1PackageOriginRestrictions = (input, context) => {
    return {
        ...(input.publish != null && { publish: input.publish }),
        ...(input.upstream != null && { upstream: input.upstream }),
    };
};
const serializeAws_restJson1PackageVersionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1PackageVersionRevisionMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: value,
        };
    }, {});
};
const serializeAws_restJson1Tag = (input, context) => {
    return {
        ...(input.key != null && { key: input.key }),
        ...(input.value != null && { value: input.value }),
    };
};
const serializeAws_restJson1TagKeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return entry;
    });
};
const serializeAws_restJson1TagList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1Tag(entry, context);
    });
};
const serializeAws_restJson1UpstreamRepository = (input, context) => {
    return {
        ...(input.repositoryName != null && { repositoryName: input.repositoryName }),
    };
};
const serializeAws_restJson1UpstreamRepositoryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return serializeAws_restJson1UpstreamRepository(entry, context);
    });
};
const deserializeAws_restJson1AssetHashes = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: (0, smithy_client_1.expectString)(value),
        };
    }, {});
};
const deserializeAws_restJson1AssetSummary = (output, context) => {
    return {
        hashes: output.hashes != null ? deserializeAws_restJson1AssetHashes(output.hashes, context) : undefined,
        name: (0, smithy_client_1.expectString)(output.name),
        size: (0, smithy_client_1.expectLong)(output.size),
    };
};
const deserializeAws_restJson1AssetSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1AssetSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1DomainDescription = (output, context) => {
    return {
        arn: (0, smithy_client_1.expectString)(output.arn),
        assetSizeBytes: (0, smithy_client_1.expectLong)(output.assetSizeBytes),
        createdTime: output.createdTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdTime)))
            : undefined,
        encryptionKey: (0, smithy_client_1.expectString)(output.encryptionKey),
        name: (0, smithy_client_1.expectString)(output.name),
        owner: (0, smithy_client_1.expectString)(output.owner),
        repositoryCount: (0, smithy_client_1.expectInt32)(output.repositoryCount),
        s3BucketArn: (0, smithy_client_1.expectString)(output.s3BucketArn),
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_restJson1DomainEntryPoint = (output, context) => {
    return {
        externalConnectionName: (0, smithy_client_1.expectString)(output.externalConnectionName),
        repositoryName: (0, smithy_client_1.expectString)(output.repositoryName),
    };
};
const deserializeAws_restJson1DomainSummary = (output, context) => {
    return {
        arn: (0, smithy_client_1.expectString)(output.arn),
        createdTime: output.createdTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.createdTime)))
            : undefined,
        encryptionKey: (0, smithy_client_1.expectString)(output.encryptionKey),
        name: (0, smithy_client_1.expectString)(output.name),
        owner: (0, smithy_client_1.expectString)(output.owner),
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_restJson1DomainSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1DomainSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1LicenseInfo = (output, context) => {
    return {
        name: (0, smithy_client_1.expectString)(output.name),
        url: (0, smithy_client_1.expectString)(output.url),
    };
};
const deserializeAws_restJson1LicenseInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1LicenseInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PackageDependency = (output, context) => {
    return {
        dependencyType: (0, smithy_client_1.expectString)(output.dependencyType),
        namespace: (0, smithy_client_1.expectString)(output.namespace),
        package: (0, smithy_client_1.expectString)(output.package),
        versionRequirement: (0, smithy_client_1.expectString)(output.versionRequirement),
    };
};
const deserializeAws_restJson1PackageDependencyList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PackageDependency(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PackageDescription = (output, context) => {
    return {
        format: (0, smithy_client_1.expectString)(output.format),
        name: (0, smithy_client_1.expectString)(output.name),
        namespace: (0, smithy_client_1.expectString)(output.namespace),
        originConfiguration: output.originConfiguration != null
            ? deserializeAws_restJson1PackageOriginConfiguration(output.originConfiguration, context)
            : undefined,
    };
};
const deserializeAws_restJson1PackageOriginConfiguration = (output, context) => {
    return {
        restrictions: output.restrictions != null
            ? deserializeAws_restJson1PackageOriginRestrictions(output.restrictions, context)
            : undefined,
    };
};
const deserializeAws_restJson1PackageOriginRestrictions = (output, context) => {
    return {
        publish: (0, smithy_client_1.expectString)(output.publish),
        upstream: (0, smithy_client_1.expectString)(output.upstream),
    };
};
const deserializeAws_restJson1PackageSummary = (output, context) => {
    return {
        format: (0, smithy_client_1.expectString)(output.format),
        namespace: (0, smithy_client_1.expectString)(output.namespace),
        originConfiguration: output.originConfiguration != null
            ? deserializeAws_restJson1PackageOriginConfiguration(output.originConfiguration, context)
            : undefined,
        package: (0, smithy_client_1.expectString)(output.package),
    };
};
const deserializeAws_restJson1PackageSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PackageSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1PackageVersionDescription = (output, context) => {
    return {
        displayName: (0, smithy_client_1.expectString)(output.displayName),
        format: (0, smithy_client_1.expectString)(output.format),
        homePage: (0, smithy_client_1.expectString)(output.homePage),
        licenses: output.licenses != null ? deserializeAws_restJson1LicenseInfoList(output.licenses, context) : undefined,
        namespace: (0, smithy_client_1.expectString)(output.namespace),
        origin: output.origin != null ? deserializeAws_restJson1PackageVersionOrigin(output.origin, context) : undefined,
        packageName: (0, smithy_client_1.expectString)(output.packageName),
        publishedTime: output.publishedTime != null
            ? (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(output.publishedTime)))
            : undefined,
        revision: (0, smithy_client_1.expectString)(output.revision),
        sourceCodeRepository: (0, smithy_client_1.expectString)(output.sourceCodeRepository),
        status: (0, smithy_client_1.expectString)(output.status),
        summary: (0, smithy_client_1.expectString)(output.summary),
        version: (0, smithy_client_1.expectString)(output.version),
    };
};
const deserializeAws_restJson1PackageVersionError = (output, context) => {
    return {
        errorCode: (0, smithy_client_1.expectString)(output.errorCode),
        errorMessage: (0, smithy_client_1.expectString)(output.errorMessage),
    };
};
const deserializeAws_restJson1PackageVersionErrorMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1PackageVersionError(value, context),
        };
    }, {});
};
const deserializeAws_restJson1PackageVersionOrigin = (output, context) => {
    return {
        domainEntryPoint: output.domainEntryPoint != null
            ? deserializeAws_restJson1DomainEntryPoint(output.domainEntryPoint, context)
            : undefined,
        originType: (0, smithy_client_1.expectString)(output.originType),
    };
};
const deserializeAws_restJson1PackageVersionSummary = (output, context) => {
    return {
        origin: output.origin != null ? deserializeAws_restJson1PackageVersionOrigin(output.origin, context) : undefined,
        revision: (0, smithy_client_1.expectString)(output.revision),
        status: (0, smithy_client_1.expectString)(output.status),
        version: (0, smithy_client_1.expectString)(output.version),
    };
};
const deserializeAws_restJson1PackageVersionSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1PackageVersionSummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1RepositoryDescription = (output, context) => {
    return {
        administratorAccount: (0, smithy_client_1.expectString)(output.administratorAccount),
        arn: (0, smithy_client_1.expectString)(output.arn),
        description: (0, smithy_client_1.expectString)(output.description),
        domainName: (0, smithy_client_1.expectString)(output.domainName),
        domainOwner: (0, smithy_client_1.expectString)(output.domainOwner),
        externalConnections: output.externalConnections != null
            ? deserializeAws_restJson1RepositoryExternalConnectionInfoList(output.externalConnections, context)
            : undefined,
        name: (0, smithy_client_1.expectString)(output.name),
        upstreams: output.upstreams != null
            ? deserializeAws_restJson1UpstreamRepositoryInfoList(output.upstreams, context)
            : undefined,
    };
};
const deserializeAws_restJson1RepositoryExternalConnectionInfo = (output, context) => {
    return {
        externalConnectionName: (0, smithy_client_1.expectString)(output.externalConnectionName),
        packageFormat: (0, smithy_client_1.expectString)(output.packageFormat),
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_restJson1RepositoryExternalConnectionInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RepositoryExternalConnectionInfo(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1RepositorySummary = (output, context) => {
    return {
        administratorAccount: (0, smithy_client_1.expectString)(output.administratorAccount),
        arn: (0, smithy_client_1.expectString)(output.arn),
        description: (0, smithy_client_1.expectString)(output.description),
        domainName: (0, smithy_client_1.expectString)(output.domainName),
        domainOwner: (0, smithy_client_1.expectString)(output.domainOwner),
        name: (0, smithy_client_1.expectString)(output.name),
    };
};
const deserializeAws_restJson1RepositorySummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1RepositorySummary(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1ResourcePolicy = (output, context) => {
    return {
        document: (0, smithy_client_1.expectString)(output.document),
        resourceArn: (0, smithy_client_1.expectString)(output.resourceArn),
        revision: (0, smithy_client_1.expectString)(output.revision),
    };
};
const deserializeAws_restJson1SuccessfulPackageVersionInfo = (output, context) => {
    return {
        revision: (0, smithy_client_1.expectString)(output.revision),
        status: (0, smithy_client_1.expectString)(output.status),
    };
};
const deserializeAws_restJson1SuccessfulPackageVersionInfoMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        return {
            ...acc,
            [key]: deserializeAws_restJson1SuccessfulPackageVersionInfo(value, context),
        };
    }, {});
};
const deserializeAws_restJson1Tag = (output, context) => {
    return {
        key: (0, smithy_client_1.expectString)(output.key),
        value: (0, smithy_client_1.expectString)(output.value),
    };
};
const deserializeAws_restJson1TagList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1Tag(entry, context);
    });
    return retVal;
};
const deserializeAws_restJson1UpstreamRepositoryInfo = (output, context) => {
    return {
        repositoryName: (0, smithy_client_1.expectString)(output.repositoryName),
    };
};
const deserializeAws_restJson1UpstreamRepositoryInfoList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_restJson1UpstreamRepositoryInfo(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => {
    var _a;
    return ({
        httpStatusCode: output.statusCode,
        requestId: (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"],
    });
};
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
